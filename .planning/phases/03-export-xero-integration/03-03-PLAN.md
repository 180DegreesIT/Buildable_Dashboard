---
phase: 03-export-xero-integration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - server/prisma/schema.prisma
  - server/src/services/XeroAuthService.ts
  - server/src/services/XeroSyncService.ts
  - server/src/services/XeroScheduler.ts
  - server/src/routes/xero.ts
  - server/src/index.ts
  - client/src/components/admin/SystemStatus.tsx
  - client/src/lib/settingsApi.ts
  - server/.env.example
autonomous: true

must_haves:
  truths:
    - "Xero OAuth2 authorisation flow works end-to-end in mock mode (redirect, consent simulation, callback, encrypted token storage)"
    - "Xero sync services can pull P&L, invoices, and bank summary data into the correct database tables in mock mode"
    - "Sync scheduling runs via node-cron with configurable interval and a manual Sync Now button in admin settings"
    - "Xero connection status is displayed in admin settings SystemStatus card (connected/disconnected, last sync time)"
    - "Rate limiting respects Xero limits (60 calls/min, 5000/day) with exponential backoff on 429"
    - "Tokens are securely stored (encrypted, not plaintext in database)"
  artifacts:
    - path: "server/src/services/XeroAuthService.ts"
      provides: "OAuth2 flow, token encrypt/decrypt/refresh, mock mode"
      exports: ["XeroAuthService"]
    - path: "server/src/services/XeroSyncService.ts"
      provides: "P&L, invoice, bank summary sync from Xero to DB"
      exports: ["XeroSyncService"]
    - path: "server/src/services/XeroScheduler.ts"
      provides: "node-cron daily sync scheduling"
      exports: ["XeroScheduler"]
    - path: "server/src/routes/xero.ts"
      provides: "Xero OAuth + sync + status API routes"
      contains: "router.get"
    - path: "server/prisma/schema.prisma"
      provides: "XeroToken and XeroSyncLog models"
      contains: "model XeroToken"
  key_links:
    - from: "server/src/routes/xero.ts"
      to: "server/src/services/XeroAuthService.ts"
      via: "OAuth2 connect/callback/disconnect routes"
      pattern: "XeroAuthService"
    - from: "server/src/routes/xero.ts"
      to: "server/src/services/XeroSyncService.ts"
      via: "Manual sync trigger route"
      pattern: "XeroSyncService"
    - from: "client/src/components/admin/SystemStatus.tsx"
      to: "/api/v1/xero/status"
      via: "fetch on mount to display connection state"
      pattern: "api/v1/xero/status"

user_setup:
  - service: xero
    why: "Xero accounting API integration (scaffolded in mock mode)"
    env_vars:
      - name: XERO_CLIENT_ID
        source: "Xero Developer Portal -> My Apps -> App credentials (PENDING from 180D)"
      - name: XERO_CLIENT_SECRET
        source: "Xero Developer Portal -> My Apps -> App credentials (PENDING from 180D)"
      - name: XERO_ENCRYPTION_KEY
        source: "Generate with: node -e \"console.log(require('crypto').randomBytes(32).toString('hex'))\""
      - name: XERO_MOCK_MODE
        source: "Set to 'true' for development without live Xero connection"
---

<objective>
Build the Xero API integration scaffold: OAuth2 authorisation flow with encrypted token storage, sync services for P&L/invoices/bank summary, scheduled daily sync via node-cron, rate limiting, and mock mode for development. Wire the Xero card in admin settings to show real connection status.

Purpose: When Xero credentials arrive from 180D, the system is ready to connect and sync financial data automatically. Mock mode allows full testing of the flow without live credentials.
Output: Complete Xero integration scaffold operating in mock mode, with admin UI showing connection status and Sync Now button.
</objective>

<execution_context>
@C:/Users/Dev180D/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dev180D/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-export-xero-integration/03-RESEARCH.md

Key codebase files:
@server/prisma/schema.prisma
@server/src/index.ts
@client/src/components/admin/SystemStatus.tsx
@client/src/lib/settingsApi.ts
@server/src/services/FinancialService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database models, Xero auth service, and sync services</name>
  <files>
    server/prisma/schema.prisma
    server/src/services/XeroAuthService.ts
    server/src/services/XeroSyncService.ts
    server/src/services/XeroScheduler.ts
    server/.env.example
  </files>
  <action>
**Install dependencies:**
```bash
cd server && npm install xero-node node-cron && npm install -D @types/node-cron
```

**Add Prisma models to `server/prisma/schema.prisma`:**

Append these two models at the end of the schema:

```prisma
model XeroToken {
  id             Int      @id @default(autoincrement())
  tenantId       String   @unique @map("tenant_id")
  tenantName     String   @map("tenant_name")
  accessToken    String   @map("access_token")    // AES-256-GCM encrypted
  refreshToken   String   @map("refresh_token")   // AES-256-GCM encrypted
  idToken        String?  @map("id_token")
  tokenType      String   @default("Bearer") @map("token_type")
  expiresAt      DateTime @map("expires_at")
  scope          String
  connectedAt    DateTime @default(now()) @map("connected_at")
  lastSyncAt     DateTime? @map("last_sync_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  @@map("xero_tokens")
}

model XeroSyncLog {
  id          Int      @id @default(autoincrement())
  syncType    String   @map("sync_type")    // 'profit_and_loss', 'invoices', 'bank_summary'
  weekEnding  DateTime @map("week_ending") @db.Date
  status      String   // 'success', 'failed', 'partial'
  recordCount Int      @default(0) @map("record_count")
  errorLog    Json?    @map("error_log")
  startedAt   DateTime @default(now()) @map("started_at")
  completedAt DateTime? @map("completed_at")

  @@map("xero_sync_logs")
}
```

Run migration: `cd server && npx prisma migrate dev --name add_xero_models`

**Create `server/src/services/XeroAuthService.ts`:**

Singleton class `XeroAuthService`:

**Token encryption (AES-256-GCM):**
- Use Node.js built-in `crypto` module
- Key from `process.env.XERO_ENCRYPTION_KEY` (32 bytes hex-encoded)
- `encrypt(plaintext: string): string` -- generates random 16-byte IV, encrypts, returns `iv:authTag:ciphertext` (all hex)
- `decrypt(ciphertext: string): string` -- parses iv:authTag:ciphertext, decrypts
- If XERO_ENCRYPTION_KEY is not set, throw a clear error at startup (not at encrypt time)

**Mock mode detection:**
- `isMockMode(): boolean` returns `process.env.XERO_MOCK_MODE === 'true'`

**OAuth2 flow (real mode):**
- `getConsentUrl(): Promise<string>` -- initialises XeroClient with clientId, clientSecret, redirectUri (`${SERVER_URL}/api/v1/xero/callback`), scopes (openid, profile, email, accounting.settings, accounting.transactions, accounting.reports.read, accounting.contacts.read, offline_access). Returns consent URL.
- `handleCallback(callbackUrl: string): Promise<void>` -- exchanges code for tokens via xero.apiCallback(), encrypts tokens, stores in XeroToken model via Prisma upsert (by tenantId).
- `getAuthenticatedClient(): Promise<XeroClient>` -- loads tokens from DB, decrypts, checks expiry. If expired, refreshes using refresh token, re-encrypts, updates DB. Returns authenticated XeroClient. Implement refresh mutex using a module-level promise variable to prevent concurrent refreshes.

**OAuth2 flow (mock mode):**
- `getConsentUrl()` returns `'/api/v1/xero/callback?mock=true'` (self-redirect)
- `handleCallback()` stores mock token with fake tenantId 'mock-tenant-001', tenantName 'Mock Organisation'
- `getAuthenticatedClient()` returns null (sync service uses mock data instead)

**Status:**
- `getConnectionStatus(): Promise<{ connected: boolean; tenantName?: string; lastSyncAt?: Date; mockMode: boolean }>` -- queries XeroToken table, returns status

**Disconnect:**
- `disconnect(): Promise<void>` -- deletes XeroToken records

**Create `server/src/services/XeroSyncService.ts`:**

Class `XeroSyncService`:

**Rate limiter (internal):**
- Track API calls in a sliding 60-second window (array of timestamps)
- Before each call, check if window has 55+ calls (leave headroom). If so, wait until oldest call falls outside window.
- On 429 response: exponential backoff (2^attempt seconds, max 60 seconds, max 3 retries)
- Track daily count, refuse calls if approaching 4800/day (safety margin)

**Sync methods (all return `Promise<XeroSyncLog>`):**

`syncProfitAndLoss(weekEnding: string)`:
- If mock mode: generate realistic mock P&L data (use values similar to existing backfilled data -- Total Trading Income ~$200K-300K, COGS ~30%, etc.)
- If real mode: call `xero.accountingApi.getReportProfitAndLoss(tenantId, startDate, endDate, ...)` where startDate is Sunday before weekEnding and endDate is weekEnding (Saturday)
- Transform Xero report structure into `financial_weekly` record fields
- Upsert into `financial_weekly` with `dataSource: 'xero_api'`
- Log result in `XeroSyncLog`

`syncInvoices(weekEnding: string)`:
- If mock mode: generate mock invoice data by region
- If real mode: call `xero.accountingApi.getInvoices(tenantId, ...)` filtered by date range
- Group invoices by type (residential/commercial/retrospective) and sum
- Upsert into `revenue_weekly` with `dataSource: 'xero_api'`
- Log result in `XeroSyncLog`

`syncBankSummary(weekEnding: string)`:
- If mock mode: generate mock bank balance data
- If real mode: call relevant Xero endpoint for bank account balances
- Upsert into `cash_position_weekly` with `dataSource: 'xero_api'`
- Log result in `XeroSyncLog`

`syncAll(weekEnding: string)`:
- Calls all three sync methods sequentially (not parallel, to respect rate limits)
- Returns array of sync logs

**Create `server/src/services/XeroScheduler.ts`:**

Uses `node-cron` to schedule daily sync:

```typescript
import cron from 'node-cron';

class XeroScheduler {
  private task: cron.ScheduledTask | null = null;

  start(cronExpression: string = '0 6 * * *') { // Default: daily 6am
    // Convert to AEST: '0 6 * * *' is 6am server time
    // Since server is in AU, this is AEST
    this.task = cron.schedule(cronExpression, async () => {
      // Determine current week ending (nearest past Saturday)
      // Call XeroSyncService.syncAll()
      // Log results
    });
  }

  stop() {
    this.task?.stop();
    this.task = null;
  }

  isRunning(): boolean {
    return this.task !== null;
  }
}
```

Export singleton instance. Do NOT auto-start -- start is called from server index or from route handler.

**Update `server/.env.example`:**

Add these variables (create file if it doesn't exist, or append):
```
# Xero Integration
XERO_CLIENT_ID=your_xero_client_id
XERO_CLIENT_SECRET=your_xero_client_secret
XERO_ENCRYPTION_KEY=generate_with_node_crypto_random_bytes_32_hex
XERO_MOCK_MODE=true
```
  </action>
  <verify>
    - `cd server && npx prisma migrate dev --name add_xero_models` succeeds
    - `cd server && npx tsc --noEmit` compiles (pre-existing warnings only)
    - Prisma generates XeroToken and XeroSyncLog types
    - `node -e "require('xero-node')"` succeeds in server dir
    - `node -e "require('node-cron')"` succeeds in server dir
  </verify>
  <done>
    - XeroToken and XeroSyncLog models in schema.prisma with migration applied
    - XeroAuthService handles OAuth2 flow + mock mode + token encryption
    - XeroSyncService syncs P&L, invoices, bank summary (mock data in mock mode)
    - XeroScheduler provides cron-based daily sync with start/stop
    - Rate limiting with sliding window and exponential backoff
    - .env.example documents required env vars
  </done>
</task>

<task type="auto">
  <name>Task 2: API routes and admin UI wiring</name>
  <files>
    server/src/routes/xero.ts
    server/src/index.ts
    client/src/components/admin/SystemStatus.tsx
    client/src/lib/settingsApi.ts
  </files>
  <action>
**Create `server/src/routes/xero.ts`:**

Express Router with these routes:

`GET /connect` -- Initiate Xero OAuth2 flow:
- Call `XeroAuthService.getConsentUrl()`
- Redirect user to consent URL (or return URL as JSON in mock mode)

`GET /callback` -- OAuth2 callback:
- Call `XeroAuthService.handleCallback(req.url)` (or full URL)
- On success: redirect to `/admin-settings?xero=connected` (or return success JSON)
- On error: redirect to `/admin-settings?xero=error`

`GET /status` -- Get connection status:
- Call `XeroAuthService.getConnectionStatus()`
- Return JSON: `{ connected, tenantName, lastSyncAt, mockMode, schedulerRunning }`

`POST /disconnect` -- Disconnect Xero:
- Call `XeroAuthService.disconnect()`
- Stop scheduler
- Return `{ success: true }`

`POST /sync` -- Manual sync trigger:
- Get `weekEnding` from query/body (default to current week ending)
- Call `XeroSyncService.syncAll(weekEnding)`
- Return sync results

`GET /sync-logs` -- Get recent sync logs:
- Query XeroSyncLog, order by startedAt desc, limit 20
- Return JSON array

`POST /scheduler/start` -- Start sync scheduler:
- Call `XeroScheduler.start()`
- Return `{ running: true }`

`POST /scheduler/stop` -- Stop sync scheduler:
- Call `XeroScheduler.stop()`
- Return `{ running: false }`

All routes require authentication (already applied by the app.use('/api/v1', authenticate) middleware).

**Update `server/src/index.ts`:**

1. Import xero routes: `import xeroRoutes from './routes/xero.js';`
2. Register: `app.use('/api/v1/xero', xeroRoutes);`
3. **IMPORTANT:** The xero callback route needs to work. Since the `/api/v1/xero/callback` is behind the auth middleware, and in dev mode auth is auto-bypassed, this is fine. In production, the OAuth callback is a redirect from Xero and needs the session -- add a TODO comment for production auth token handling.

**Update `client/src/components/admin/SystemStatus.tsx`:**

Transform the Xero card from static placeholder to interactive:

1. Add state: `xeroStatus` with `{ connected, tenantName, lastSyncAt, mockMode, schedulerRunning }`, `loading`, `syncing`, `error`
2. Fetch status on mount from `/api/v1/xero/status`
3. Update the Xero card to show:
   - **Connected state:** Green badge "Connected" (or "Connected (Mock)" if mockMode), tenant name, last sync time formatted as DD/MM/YYYY HH:mm
   - **Disconnected state:** Gray badge "Not Connected", Connect button enabled
   - **Connect button:** calls `/api/v1/xero/connect` (window.location = response URL for OAuth redirect, or direct redirect)
   - **Disconnect button:** calls POST `/api/v1/xero/disconnect`, refreshes status
   - **Sync Now button:** calls POST `/api/v1/xero/sync`, shows spinner while syncing, displays result
   - **Scheduler toggle:** Start/Stop button calling POST `/api/v1/xero/scheduler/start` or `stop`
4. Keep 3CX and Reportei cards as-is (static, disabled)
5. Keep the existing card styling consistent with the design language

**Update `client/src/lib/settingsApi.ts`** (or create a new `xeroApi.ts` -- check what exists):

Add API functions:
- `fetchXeroStatus(): Promise<XeroStatus>`
- `connectXero(): Promise<{ url: string }>`
- `disconnectXero(): Promise<void>`
- `triggerXeroSync(weekEnding?: string): Promise<SyncResult>`
- `startXeroScheduler(): Promise<void>`
- `stopXeroScheduler(): Promise<void>`

If settingsApi.ts is already large, create a separate `client/src/lib/xeroApi.ts` instead.
  </action>
  <verify>
    - `cd server && npx tsc --noEmit` compiles
    - `cd client && npx tsc --noEmit` compiles
    - Server starts, `curl http://localhost:6001/api/v1/xero/status` returns JSON with `connected: false, mockMode: true`
    - Navigate to Admin Settings page, Xero card shows "Not Connected" with an enabled "Connect" button
    - Click Connect -- in mock mode, should redirect back to admin settings with connected status
    - Click Sync Now -- should show syncing state and then success (mock data synced)
    - Verify XeroSyncLog table has entries after mock sync
  </verify>
  <done>
    - Xero API routes registered at /api/v1/xero/*
    - Admin Settings Xero card is interactive (connect, disconnect, sync now, scheduler toggle)
    - Mock mode works end-to-end: connect -> sync -> view status
    - Sync logs stored in database
    - XERO-01 through XERO-10 requirements addressed
  </done>
</task>

</tasks>

<verification>
1. Server compiles: `cd server && npx tsc --noEmit` (pre-existing warnings only)
2. Client compiles: `cd client && npx tsc --noEmit`
3. Database: XeroToken and XeroSyncLog tables exist after migration
4. Mock flow: Connect (mock) -> Status shows connected -> Sync Now -> Sync logs created -> Disconnect -> Status shows not connected
5. Rate limiter: XeroSyncService respects 60/min limit (verified by code review)
6. Token encryption: Tokens stored as encrypted strings in DB (not plaintext)
7. Scheduler: Start scheduler, verify cron task registered, stop scheduler
</verification>

<success_criteria>
- XERO-01: OAuth2 authorisation flow works end-to-end (mock mode)
- XERO-02: Encrypted token storage with AES-256-GCM
- XERO-03: Token refresh handling in auth service (tested in mock mode)
- XERO-04: P&L sync service -> financial_weekly
- XERO-05: Invoice sync service -> revenue_weekly
- XERO-06: Bank summary sync service -> cash_position_weekly
- XERO-07: Configurable scheduling (node-cron) + manual Sync Now button
- XERO-08: Rate limiting (60/min, 5000/day, exponential backoff)
- XERO-09: Mock mode for development without live Xero connection
- XERO-10: Xero connection status displayed in admin settings
</success_criteria>

<output>
After completion, create `.planning/phases/03-export-xero-integration/03-03-SUMMARY.md`
</output>
