---
phase: 01-admin-user-management
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - server/src/routes/users.ts
  - server/src/index.ts
  - client/src/lib/userApi.ts
  - client/src/components/users/UserManagement.tsx
  - client/src/components/users/UserTable.tsx
  - client/src/components/users/PermissionMatrix.tsx
  - client/src/components/users/RoleConfirmDialog.tsx
  - client/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can view all users in a sortable table showing display name, email, role, active status, and last login"
    - "Admin can change a user's role via dropdown and is prompted to apply default permissions for that role"
    - "Admin can toggle Read/Write/No Access for each user-page combination in a permission matrix grid"
    - "Saving permissions persists them to the database and they take effect on the user's next request"
    - "Changing role to Super Admin auto-fills all permissions to Write; changing to Staff auto-fills minimal access"
    - "In dev mode, admin can create test users via a 'Create User' form"
  artifacts:
    - path: "server/src/routes/users.ts"
      provides: "User management API endpoints (list, role update, permission batch, create)"
      exports: ["default (Router)"]
    - path: "client/src/components/users/UserManagement.tsx"
      provides: "Main user management page container"
      exports: ["default"]
    - path: "client/src/components/users/PermissionMatrix.tsx"
      provides: "Permission grid with inline dropdowns for all 13 DashboardPage values"
      exports: ["default"]
    - path: "client/src/lib/userApi.ts"
      provides: "User management API client functions"
      exports: ["fetchUsers", "updateUserRole", "updateUserPermissions", "createUser"]
  key_links:
    - from: "client/src/components/users/UserTable.tsx"
      to: "/api/v1/users"
      via: "userApi.fetchUsers on mount"
      pattern: "fetchUsers"
    - from: "client/src/components/users/PermissionMatrix.tsx"
      to: "/api/v1/users/:id/permissions"
      via: "userApi.updateUserPermissions on save"
      pattern: "updateUserPermissions"
    - from: "client/src/components/users/UserTable.tsx"
      to: "/api/v1/users/:id/role"
      via: "userApi.updateUserRole on dropdown change"
      pattern: "updateUserRole"
    - from: "server/src/routes/users.ts"
      to: "permissions.ts ROLE_DEFAULTS"
      via: "Import ROLE_DEFAULTS to apply default permissions on role change"
      pattern: "ROLE_DEFAULTS|applyDefaults"
---

<objective>
Build the User Management backend API and frontend page, including user listing with sorting, role assignment with default permission auto-fill, bulk permission matrix editing, and dev-mode user creation. This completes the access control UI for Phase 1.

Purpose: Administrators need to see who has access to the system, assign appropriate roles, and fine-tune page-level permissions. This is the other half of the admin feature set, alongside the settings page from Plan 01.

Output: Working User Management page at `/user_management` with user table, role dropdowns, permission matrix grid, role change confirmation dialog, and dev-mode user creation.
</objective>

<execution_context>
@C:/Users/Dev180D/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dev180D/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-admin-user-management/01-CONTEXT.md
@.planning/phases/01-admin-user-management/01-RESEARCH.md
@.planning/phases/01-admin-user-management/01-01-SUMMARY.md

Key existing files to reference:
@server/src/routes/targets.ts — Route pattern (Router + Zod + validateBody + try/catch/next)
@server/src/middleware/validation.ts — validateBody middleware
@server/src/middleware/permissions.ts — ROLE_DEFAULTS, ADMIN_ONLY_PAGES, STAFF_READABLE_PAGES (export these if not already exported)
@server/src/middleware/auth.ts — User type on req.user
@server/src/services/AuthService.ts — getDevUser pattern
@server/src/index.ts — Route registration (already modified by Plan 01)
@server/prisma/schema.prisma — User, UserPermission, UserRole, PermissionLevel, DashboardPage enums
@client/src/lib/api.ts — API client pattern
@client/src/App.tsx — Page routing (already modified by Plan 01 to include SettingsProvider)
@client/src/components/layout/Sidebar.tsx — PageId type includes 'user_management'
</context>

<tasks>

<task type="auto">
  <name>Task 1: User management backend API</name>
  <files>
    server/src/routes/users.ts
    server/src/index.ts
    server/src/middleware/permissions.ts
  </files>
  <action>
**1. Export role defaults from `server/src/middleware/permissions.ts`:**
- Export `ROLE_DEFAULTS`, `ADMIN_ONLY_PAGES`, and `STAFF_READABLE_PAGES` so they can be imported by the users route. These are currently `const` — simply add `export` keyword. Also export a helper function `getDefaultPermissionsForRole(role: UserRole): Array<{ page: DashboardPage; permissionLevel: PermissionLevel }>` that computes the full set of 13 page permissions for a given role:
  - super_admin: all 13 pages get 'write'
  - executive: all pages get 'read' EXCEPT admin_settings and user_permission_management which get 'no_access'
  - manager: same as executive
  - staff: STAFF_READABLE_PAGES get 'read', everything else gets 'no_access'
- This function encapsulates the logic already expressed by ROLE_DEFAULTS + ADMIN_ONLY_PAGES + STAFF_READABLE_PAGES but returns concrete permission entries for all pages.

**2. Create `server/src/routes/users.ts`:**
Follow the exact pattern from targets.ts (Router, Zod, validateBody, try/catch/next).

Endpoints:

- `GET /` — List all users with permissions. Requires `requirePermission('user_permission_management', 'read')`. Query: `prisma.user.findMany({ include: { permissions: true }, orderBy: { displayName: 'asc' } })`. Return array of users.

- `GET /:id` — Get single user with permissions. Requires read permission. Return user with permissions.

- `PUT /:id/role` — Update user role. Requires `requirePermission('user_permission_management', 'write')`. Zod body: `{ role: z.enum(['super_admin', 'executive', 'manager', 'staff']), applyDefaults: z.boolean().default(false) }`. Update user role. If `applyDefaults` is true, delete all existing UserPermission rows for this user and create new ones using `getDefaultPermissionsForRole(role)` inside a Prisma transaction. Return updated user with permissions.

- `PUT /:id/permissions` — Bulk update permissions. Requires write permission. Zod body: `{ permissions: z.array(z.object({ page: z.enum([...all 13 DashboardPage values...]), permissionLevel: z.enum(['read', 'write', 'no_access']) })) }`. Use a Prisma `$transaction`: delete all existing permissions for the user, then `createMany` with the new permission set. Return updated user with permissions.

- `PUT /:id/status` — Toggle active/inactive. Requires write permission. Zod body: `{ isActive: z.boolean() }`. Update user. Return updated user.

- `POST /` — Create user (dev mode only). Guard with: `if (process.env.NODE_ENV !== 'development') return res.status(403).json(...)`. Zod body: `{ email: z.string().email(), displayName: z.string().min(1).max(100), role: z.enum([...roles...]).default('staff') }`. Create user with prisma. If a user with that email already exists, return 409 Conflict. Apply default permissions for the assigned role. Return created user with permissions.

All DashboardPage enum values for Zod (hardcode the 13 values): `'executive_summary', 'financial_deep_dive', 'pl_monthly_detail', 'sales_pipeline', 'marketing_leads', 'operations_productivity', 'regional_performance', 'cash_position', 'data_management', 'target_management', 'staff_management', 'admin_settings', 'user_permission_management'`

**3. Update `server/src/index.ts`:**
- Add `import usersRoutes from './routes/users.js';`
- Add `app.use('/api/v1/users', usersRoutes);` in the route registration section
  </action>
  <verify>
1. `cd C:/Projects/buildable_dashboard/server && npx tsc --noEmit` — compiles without new errors
2. Start dev server and test:
   - `curl http://localhost:6001/api/v1/users` — returns array of users with permissions (200)
   - `curl -X PUT http://localhost:6001/api/v1/users/1/role -H "Content-Type: application/json" -d '{"role":"executive","applyDefaults":true}'` — returns updated user with default executive permissions
   - `curl -X PUT http://localhost:6001/api/v1/users/1/permissions -H "Content-Type: application/json" -d '{"permissions":[{"page":"executive_summary","permissionLevel":"write"},{"page":"financial_deep_dive","permissionLevel":"read"}]}'` — returns user with only those 2 permissions
   - `curl -X POST http://localhost:6001/api/v1/users -H "Content-Type: application/json" -d '{"email":"test@buildable.com.au","displayName":"Test User","role":"staff"}'` — returns 201 with new user
  </verify>
  <done>
- GET /api/v1/users returns all users with their permissions
- PUT /:id/role updates role and optionally applies default permissions in a transaction
- PUT /:id/permissions bulk-replaces all permissions for a user
- PUT /:id/status toggles active/inactive
- POST / creates new user in dev mode only (403 in production)
- All endpoints protected by user_permission_management read/write as appropriate
  </done>
</task>

<task type="auto">
  <name>Task 2: User management frontend — user table, permission matrix, and role management</name>
  <files>
    client/src/lib/userApi.ts
    client/src/components/users/UserManagement.tsx
    client/src/components/users/UserTable.tsx
    client/src/components/users/PermissionMatrix.tsx
    client/src/components/users/RoleConfirmDialog.tsx
    client/src/App.tsx
  </files>
  <action>
**1. Create `client/src/lib/userApi.ts`:**
Follow the api.ts pattern. Base URL: `/api/v1/users`.

Types:
```typescript
interface UserPermissionEntry {
  id: number;
  page: string;         // DashboardPage enum value
  permissionLevel: string; // 'read' | 'write' | 'no_access'
}

interface UserRecord {
  id: number;
  email: string;
  displayName: string;
  role: string;          // 'super_admin' | 'executive' | 'manager' | 'staff'
  isActive: boolean;
  lastLogin: string | null;
  createdAt: string;
  permissions: UserPermissionEntry[];
}
```

Functions:
- `fetchUsers(): Promise<UserRecord[]>` — GET /api/v1/users
- `updateUserRole(userId: number, role: string, applyDefaults: boolean): Promise<UserRecord>` — PUT /api/v1/users/:id/role
- `updateUserPermissions(userId: number, permissions: Array<{ page: string; permissionLevel: string }>): Promise<UserRecord>` — PUT /api/v1/users/:id/permissions
- `toggleUserStatus(userId: number, isActive: boolean): Promise<UserRecord>` — PUT /api/v1/users/:id/status
- `createUser(data: { email: string; displayName: string; role?: string }): Promise<UserRecord>` — POST /api/v1/users

**2. Create `client/src/components/users/RoleConfirmDialog.tsx`:**
A modal dialog component. Props: `{ isOpen: boolean; userName: string; newRole: string; onConfirm: (applyDefaults: boolean) => void; onCancel: () => void }`.

When a role change is initiated, this dialog asks: "Change {userName}'s role to {newRole}?" with two action buttons:
- "Apply Default Permissions" — calls onConfirm(true). Shows helper text: "This will replace all current permissions with the defaults for {role}."
- "Keep Current Permissions" — calls onConfirm(false)
- Cancel button to dismiss without changing

Style: centered overlay modal, white card, rounded corners, consistent with Asana design language. Use a backdrop overlay with click-to-dismiss.

**3. Create `client/src/components/users/UserTable.tsx`:**
Props: `{ users: UserRecord[]; onSelectUser: (user: UserRecord) => void; onRoleChange: (user: UserRecord, newRole: string) => void; onToggleStatus: (user: UserRecord) => void; selectedUserId?: number }`.

Features:
- Table columns: checkbox (for bulk select), display name (with avatar initials circle), email, role (inline dropdown), active status (toggle/badge), last login (formatted DD/MM/YYYY or "Never")
- Sortable columns: click column header to sort asc/desc. Default sort: displayName ascending.
- Pagination: if >10 users, show simple pagination (Previous/Next). Start with 10 per page.
- Row click selects user (highlights row, triggers onSelectUser for permission matrix below).
- Role dropdown: inline `<select>` with options Super Admin, Executive, Manager, Staff. On change, triggers `onRoleChange` (which will open the RoleConfirmDialog).
- Active status: coloured badge — green "Active" or grey "Inactive". Click to toggle (calls onToggleStatus).
- Bulk select: checkboxes on each row. When 2+ selected, show a toolbar with "Set Role" dropdown button. Clicking it opens a role picker, which then calls onRoleChange for each selected user.
- Style: standard data table following the project's table styling pattern (white card, header row with grey bg, hover states on rows, consistent with existing dashboard tables).

**4. Create `client/src/components/users/PermissionMatrix.tsx`:**
Props: `{ user: UserRecord; onSave: (userId: number, permissions: Array<{ page: string; permissionLevel: string }>) => void; saving: boolean }`.

Features:
- Grid display: rows are DashboardPage values (all 13), columns are the permission levels
- Each row: page label (human-readable), inline `<select>` dropdown with options Read, Write, No Access
- Map all 13 DashboardPage enum values to user-facing labels:
  - executive_summary -> "Executive Summary"
  - financial_deep_dive -> "Financial Deep Dive"
  - pl_monthly_detail -> "P&L Monthly Detail"
  - sales_pipeline -> "Sales & Pipeline"
  - marketing_leads -> "Marketing & Leads"
  - operations_productivity -> "Operations"
  - regional_performance -> "Regional Performance"
  - cash_position -> "Cash Position"
  - data_management -> "Data Management"
  - target_management -> "Target Management"
  - staff_management -> "Staff Management"
  - admin_settings -> "Admin Settings"
  - user_permission_management -> "User Management"
- Group pages visually: "Dashboard Pages" group (first 8), "Management Pages" group (last 5). Use subtle section headers.
- Local state: initialise from user.permissions. For pages with no explicit permission, show the role default (greyed out / italic to indicate it's a default, not explicit). Track dirty state.
- "Save Permissions" button — only enabled when changes exist. Calls onSave with the full permission set (all 13 pages, including unchanged ones — the backend replaces all).
- "Reset to Defaults" button — fills the matrix with role defaults for the user's current role (without saving, just updates local state).

**5. Create `client/src/components/users/UserManagement.tsx`:**
Main page container.

Layout:
- Page title "User Management" with subtitle "Manage users, roles, and page-level permissions"
- Dev-mode "Create User" button (only visible when `import.meta.env.DEV` is true). Opens a small inline form or modal: display name, email, role dropdown. On submit calls `createUser()` and refreshes the user list.
- `<UserTable />` component showing all users
- When a user is selected (clicked in table), show `<PermissionMatrix />` below the table for that user
- `<RoleConfirmDialog />` — managed by state in this component

State management:
- `users: UserRecord[]` — loaded on mount via fetchUsers()
- `selectedUser: UserRecord | null` — set when row is clicked
- `roleChangeTarget: { user: UserRecord; newRole: string } | null` — triggers RoleConfirmDialog
- `saving: boolean` — for permission save loading state

Handlers:
- `handleRoleChange(user, newRole)` — opens RoleConfirmDialog by setting roleChangeTarget
- `handleRoleConfirm(applyDefaults)` — calls updateUserRole, refreshes user list, clears dialog
- `handlePermissionSave(userId, permissions)` — calls updateUserPermissions, refreshes user list, updates selectedUser
- `handleToggleStatus(user)` — calls toggleUserStatus, refreshes user list
- `handleCreateUser(data)` — calls createUser, refreshes user list

**6. Update `client/src/App.tsx`:**
- Import UserManagement from `./components/users/UserManagement`
- Replace the user_management PlaceholderPage block with `<UserManagement />`

All components use Tailwind CSS, Asana design language (white cards, soft shadows, generous spacing), Australian English for labels.
  </action>
  <verify>
1. `cd C:/Projects/buildable_dashboard/client && npx tsc --noEmit` — compiles clean
2. `cd C:/Projects/buildable_dashboard && npm run dev` — both client and server start
3. Navigate to `http://localhost:6000`, click "User Management" in sidebar:
   - User table shows at least the dev admin user with display name, email, role, status, last login
   - Click a user row — permission matrix appears below showing all 13 pages with dropdowns
   - Change permission for "Executive Summary" to "Write" -> click "Save Permissions" -> refresh page -> permission persists
   - Change role dropdown to "Executive" -> confirmation dialog appears with "Apply Default Permissions" and "Keep Current Permissions" options
   - Click "Apply Default Permissions" -> matrix updates to show executive defaults
   - "Create User" button visible (dev mode) -> create a test user -> user appears in table
4. Verify no console errors in browser dev tools
  </verify>
  <done>
- User table displays all users with sortable columns, role dropdowns, and status badges
- Clicking a user row shows the permission matrix for that user below the table
- Permission matrix shows all 13 DashboardPage values with inline dropdowns grouped into Dashboard and Management sections
- Role change triggers confirmation dialog offering to apply default permissions
- Applying defaults correctly fills: Super Admin = all Write, Staff = minimal Read on 2 pages
- Permission save persists to database and survives page refresh
- Dev-mode user creation works (Create User button visible, form submits, user appears)
- Bulk role assignment works for multiple selected users
  </done>
</task>

</tasks>

<verification>
1. **User CRUD round-trip:** Create user (dev mode) -> see in table -> change role -> verify defaults applied -> tweak individual permissions -> save -> refresh -> all persists
2. **Role defaults accuracy:** Change user to each of the 4 roles with "Apply Defaults" and verify:
   - Super Admin: all 13 pages = Write
   - Executive: all pages = Read except admin_settings and user_permission_management = No Access
   - Manager: same as Executive
   - Staff: executive_summary and regional_performance = Read, all others = No Access
3. **Permission enforcement:** After setting a user's permission for a page, verify the permission middleware actually enforces it (test with curl using a JWT for that user, or verify by checking the resolvePermission logic picks up the saved permission)
4. **No regressions:** All existing pages still load. Admin Settings page from Plan 01 still works.
</verification>

<success_criteria>
- USER-01: User list table shows display name, email, role, active/inactive status, last login
- USER-02: Role assignment works via dropdown with 4 role options
- USER-03: Permission matrix grid shows all 13 pages with Read/Write/No Access dropdowns per user
- USER-04: Changing role auto-fills default permissions when confirmed (with dialog)
- USER-05: Dev mode user creation works (Create User button + form)
- All permissions persist to database and are enforced by middleware
</success_criteria>

<output>
After completion, create `.planning/phases/01-admin-user-management/01-02-SUMMARY.md`
</output>
